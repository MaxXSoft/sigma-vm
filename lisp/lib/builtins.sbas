# Implementations of builtin functions and utility functions.


  # Offsets of Lisp object fields.
#define OFFSET_KIND         0   // Kind.
#define OFFSET_VALUE        1   // Value or pointer.
#define OFFSET_NEXT         2   // Pointer to the next object.
#define OFFSET_MOD_HANDLE   3   // Module handle (for lambda object only).
#define OFFSET_CAPTURES     4   // Captured variables (for lambda object only).

  # Lisp object kinds.
#define OBJ_NUM     0   // Number.
#define OBJ_STR     1   // String.
#define OBJ_SYM     2   // Symbol.
#define OBJ_LIST    3   // List.
#define OBJ_LAMBDA  4   // Lambda.

  # ID and name of builtin functions.
#define BUILTIN_ATOM(e)   e(atom,         1)
#define BUILTIN_NUMBER(e) e(number,       2)
#define BUILTIN_EQUAL(e)  e(equal,        3)
#define BUILTIN_CAR(e)    e(car,          4)
#define BUILTIN_CDR(e)    e(cdr,          5)
#define BUILTIN_CONS(e)   e(cons,         6)
#define BUILTIN_LIST(e)   e(list,         7)
#define BUILTIN_ADD(e)    e(builtin_add,  8)
#define BUILTIN_SUB(e)    e(builtin_sub,  9)
#define BUILTIN_MUL(e)    e(builtin_mul,  10)
#define BUILTIN_DIV(e)    e(builtin_div,  11)
#define BUILTIN_GT(e)     e(builtin_gt,   12)
#define BUILTIN_LT(e)     e(builtin_lt,   13)
#define BUILTIN_GE(e)     e(builtin_ge,   14)
#define BUILTIN_LE(e)     e(builtin_le,   15)
#define BUILTIN_EQ(e)     e(builtin_eq,   16)

  # Creates a new Lisp object with a specific,
  # leaves the value field uninitialized.
#define NEW_OBJ(obj, kind)  \
  newoc obj                 \
  dup                       \
  pushu kind                \
  stdo  OFFSET_KIND         \
  dup                       \
  pushu 0                   \
  stdo  OFFSET_NEXT

  # Defines a function that creates an object with a specific kind.
#define DEF_NEW_OBJ(name, obj, kind)  \
new_##name:                           \
  NEW_OBJ(obj, kind)                  \
  dups1                               \
  swap                                \
  stdo  OFFSET_VALUE                  \
  ret

  # Creates a new builtin object.
#define NEW_BUILTIN(name, obj_id) \
  pushu name##_impl               \
  call  new_builtin               \
  stg   obj_id

  # Declares a new builtin function.
#define DECL_BUILTIN(name, obj_id)  \
name:                               \
  ldg   obj_id                      \
  ret                               \
  .section exports                  \
  .export #name, name, 0, 1         \
  .section insts                    \
name##_impl:

  .section insts
  # Store the handle of the current module to global variable.
  stg   0
  # Initialize builtin function objects.
  BUILTIN_ATOM(NEW_BUILTIN)
  BUILTIN_NUMBER(NEW_BUILTIN)
  BUILTIN_EQUAL(NEW_BUILTIN)
  BUILTIN_CAR(NEW_BUILTIN)
  BUILTIN_CDR(NEW_BUILTIN)
  BUILTIN_CONS(NEW_BUILTIN)
  BUILTIN_LIST(NEW_BUILTIN)
  BUILTIN_ADD(NEW_BUILTIN)
  BUILTIN_SUB(NEW_BUILTIN)
  BUILTIN_MUL(NEW_BUILTIN)
  BUILTIN_DIV(NEW_BUILTIN)
  BUILTIN_GT(NEW_BUILTIN)
  BUILTIN_LT(NEW_BUILTIN)
  BUILTIN_GE(NEW_BUILTIN)
  BUILTIN_LE(NEW_BUILTIN)
  BUILTIN_EQ(NEW_BUILTIN)
  ret


  # Entry of all function calls.
  #
  # Stack layout:
  # * s0 (TOS): number of arguments.
  # * s1: the Lisp object to be invoked.
  # * s2 ...: arguments of the invocation.
invoke:
  # check if object is a lambda
  swap
  dup
  lddo  OFFSET_KIND
  pushu OBJ_LAMBDA
  eq
  bz    _not_callable
  # setup stack
  stv   0
  ldv   0
  lddo  OFFSET_CAPTURES
  swap
  ldv   0
  lddo  OFFSET_MOD_HANDLE
  ldv   0
  lddo  OFFSET_VALUE      # function PC
  # Stack layout after entered the target function:
  # * s0 (TOS): number of arguments.
  # * s1: array of captured arguments.
  # * s2 ...: other arguments.
  callexts
  ret
_not_callable:
  # object is not callable
  lac   not_callable
  jmp   panic


  # Panics and abort.
  #
  # Stack layout:
  # * s0 (TOS): error message string pointer.
panic:
  lac   fatal
  call  eprint
  call  eprint
  sys   12


  # Prints string to standard error.
eprint:
  dup
  pushu 8
  add
  swap
  lddo  0
  sys   10
  pop
  ret


  # Checks the number of arguments, panics if mismatch.
  #
  # Stack layout:
  # * s0 (TOS): expected argument number.
  # * s1: actual argument number.
check_nargs:
  eq
  bnz   1f
  lac   nargs_mismatch
  jmp   panic
1:
  ret


  # Creates a number object.
  #
  # Stack layout:
  # * s0 (TOS): a floating point number.
DEF_NEW_OBJ(num, object, OBJ_NUM)


  # Creates a string object.
  #
  # Stack layout:
  # * s0 (TOS): a string pointer.
DEF_NEW_OBJ(str, ptr_object, OBJ_STR)


  # Creates a symbol object.
  #
  # Stack layout:
  # * s0 (TOS): a string pointer.
DEF_NEW_OBJ(sym, ptr_object, OBJ_SYM)


  # Creates a list object.
  #
  # Stack layout:
  # * s0 (TOS): number of list elements.
  # * s1: list elements n - 1.
  # * ...
  # * s{n}: list elements 0.
new_list:
  # construct linked list
  pushu 0
  swap
  bznp  2f
1:
  stv   0
  swap
  dups1
  swap
  stdo  OFFSET_NEXT
  ldv   0
  loop  1b
2:
  # create new object
  NEW_OBJ(ptr_object, OBJ_LIST)
  dups1
  swap
  stdo  OFFSET_VALUE
  ret


  # Creates a lambda object.
  #
  # Stack layout:
  # * s0 (TOS): number of arguments.
  # * s1: captured variable 0.
  # * ...
  # * s{n}: captured variable n - 1.
  # * s{n + 1}: function PC.
  # * s{n + 2}: module handle.
new_lambda:
  # check argument number
  pushu 2
  sub
  bznp  2f
  # create captured variable array
  dup
  newac ptr
  stv   0
  # store variables to array
1:
  swap
  ldv   0
  swap
  std
  ldv   0
  pushu 8
  add
  stv   0
  loop  1b
  ldv   0
  jmp   3f
2:
  pushu 0
3:
  # create new object
  NEW_OBJ(func_object, OBJ_LAMBDA)
  dups1
  swap
  stdo  OFFSET_CAPTURES
  dups1
  swap
  stdo  OFFSET_VALUE
  dups1
  swap
  stdo  OFFSET_MOD_HANDLE
  ret


  # Creates a lambda object of a given builtin function.
  #
  # Stack layout:
  # * s0 (TOS): builtin function PC.
new_builtin:
  NEW_OBJ(func_object, OBJ_LAMBDA)
  dup
  ldg   0
  stdo  OFFSET_MOD_HANDLE
  dup
  pushu 0
  stdo  OFFSET_CAPTURES
  dups1
  swap
  stdo  OFFSET_VALUE
  ret


  # Builtin function `atom?`.
BUILTIN_ATOM(DECL_BUILTIN)
  # check argument number
  pushu 2
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `number?`.
BUILTIN_NUMBER(DECL_BUILTIN)
  # check argument number
  pushu 2
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `eq?`.
BUILTIN_EQUAL(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `car`.
BUILTIN_CAR(DECL_BUILTIN)
  # check argument number
  pushu 2
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `cdr`.
BUILTIN_CDR(DECL_BUILTIN)
  # check argument number
  pushu 2
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `cons`.
BUILTIN_CONS(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `list`.
BUILTIN_LIST(DECL_BUILTIN)
  # TODO
  ret


  # Builtin function `+`.
BUILTIN_ADD(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `-`.
BUILTIN_SUB(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `*`.
BUILTIN_MUL(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `/`.
BUILTIN_DIV(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `>`.
BUILTIN_GT(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `<`.
BUILTIN_LT(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `>=`.
BUILTIN_GE(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `<=`.
BUILTIN_LE(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  # Builtin function `=`.
BUILTIN_EQ(DECL_BUILTIN)
  # check argument number
  pushu 3
  call  check_nargs
  pop
  # TODO
  ret


  .section consts
fatal:
  .str  "FATAL: "
not_callable:
  .str  "object is not callable\n"
nargs_mismatch:
  .str  "number of arguments does not match\n"

object:
  .object 24, 8, [2]
ptr_object:
  .object 24, 8, [1, 2]
func_object:
  .object 40, 8, [2, 3, 4]
ptr:
  .object 8, 8, [0]


  .section exports
  .export "invoke", invoke, variadic, 0
  .export "panic", panic, 1, 0
  .export "check_nargs", check_nargs, 2, 0
  .export "new_num", new_num, 1, 1
  .export "new_str", new_str, 1, 1
  .export "new_sym", new_sym, 1, 1
  .export "new_list", new_list, variadic, 1
  .export "new_lambda", new_lambda, variadic, 1
