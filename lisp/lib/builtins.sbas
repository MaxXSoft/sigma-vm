# Implementations of builtin functions and utility functions.


  # Offsets of Lisp object fields.
#define OFFSET_KIND         0   // Kind.
#define OFFSET_VALUE        1   // Value or pointer.
#define OFFSET_NEXT         2   // Pointer to the next object.
#define OFFSET_MOD_HANDLE   3   // Module handle (for lambda object only).
#define OFFSET_CAPTURES     4   // Captured variables (for lambda object only).

  # Lisp object kinds.
#define OBJ_NUM     0   // Number.
#define OBJ_STR     1   // String.
#define OBJ_SYM     2   // Symbol.
#define OBJ_LIST    3   // List.
#define OBJ_LAMBDA  4   // Lambda.

  # Creates a new Lisp object with a specific,
  # leaves the value field uninitialized.
#define NEW_OBJ(obj, kind)  \
  newoc obj                 \
  dup                       \
  pushu kind                \
  stdo  OFFSET_KIND         \
  dup                       \
  pushu 0                   \
  stdo  OFFSET_NEXT

  # Defines a function that creates an object with a specific kind.
#define DEF_NEW_OBJ(name, obj, kind)  \
new_##name:                           \
  NEW_OBJ(obj, kind)                  \
  dups1                               \
  swap                                \
  stdo  OFFSET_VALUE                  \
  ret


  .section insts
  # Store the handle of the current module to global variable.
  stg   0
  ret


  # Entry of all function calls.
  #
  # Stack layout:
  # * s0 (TOS): number of arguments.
  # * s1: the Lisp object to be invoked.
  # * s2 ...: arguments of the invocation.
invoke:
  # store argument number
  stv   0
  # check argument number
  ldv   0
  pushu 0
  eq
  bz    1f
  lac   expect_obj
  jmp   panic
1:
  # store object
  stv   1
  # check if is a lambda
  ldv   1
  lddo  OFFSET_KIND
  pushu OBJ_LAMBDA
  eq
  bnz   invoke_lambda
  # object is not callable
  lac   not_callable
  jmp   panic


  # Calls a user-defined function.
invoke_lambda:
  # setup stack
  ldv   1
  lddo  OFFSET_CAPTURES
  ldv   0                 # number of arguments
  ldv   1
  lddo  OFFSET_MOD_HANDLE
  ldv   1
  lddo  OFFSET_VALUE      # function PC
  # Stack layout after entered the user-defined function:
  # * s0 (TOS): number of arguments.
  # * s1: array of captured arguments.
  # * s2 ...: other arguments.
  callexts
  ret


  # Panics and abort.
  #
  # Stack layout:
  # * s0 (TOS): error message string pointer.
panic:
  lac   fatal
  call  eprint
  call  eprint
  sys   12


  # Prints string to standard error.
eprint:
  dup
  pushu 8
  add
  swap
  lddo  0
  sys   10
  pop
  ret


  # Checks the number of arguments, panics if mismatch.
  #
  # Stack layout:
  # * s0 (TOS): expected argument number.
  # * s1: actual argument number.
check_nargs:
  eq
  bnz   1f
  lac   nargs_mismatch
  jmp   panic
1:
  ret


  # Creates a number object.
  #
  # Stack layout:
  # * s0 (TOS): a floating point number.
DEF_NEW_OBJ(num, object, OBJ_NUM)


  # Creates a string object.
  #
  # Stack layout:
  # * s0 (TOS): a string pointer.
DEF_NEW_OBJ(str, ptr_object, OBJ_STR)


  # Creates a symbol object.
  #
  # Stack layout:
  # * s0 (TOS): a string pointer.
DEF_NEW_OBJ(sym, ptr_object, OBJ_SYM)


  # Creates a list object.
  #
  # Stack layout:
  # * s0 (TOS): number of list elements.
  # * s1: list elements n - 1.
  # * ...
  # * s{n}: list elements 0.
new_list:
  # construct linked list
  pushu 0
  swap
  bznp  2f
1:
  stv   0
  swap
  dups1
  swap
  stdo  OFFSET_NEXT
  ldv   0
  loop  1b
2:
  # create new object
  NEW_OBJ(ptr_object, OBJ_LIST)
  dups1
  swap
  stdo  OFFSET_VALUE
  ret


  # Creates a lambda object.
  #
  # Stack layout:
  # * s0 (TOS): number of arguments.
  # * s1: captured variable 0.
  # * ...
  # * s{n}: captured variable n - 1.
  # * s{n + 1}: function PC.
  # * s{n + 2}: module handle.
new_lambda:
  # create captured variable array
  pushu 2
  sub
  dup
  newac ptr
  stv   0
  # store variables to array
  bznp  2f
1:
  swap
  ldv   0
  swap
  std
  ldv   0
  pushu 8
  add
  stv   0
  loop  1b
2:
  ldv   0
  # create new object
  NEW_OBJ(func_object, OBJ_LAMBDA)
  dups1
  swap
  stdo  OFFSET_CAPTURES
  dups1
  swap
  stdo  OFFSET_VALUE
  dups1
  swap
  stdo  OFFSET_MOD_HANDLE
  ret


  # Builtin function `atom?`.
atom:
  # check argument number
  ldv   0
  pushu 2
  call  check_nargs
  # TODO
  ret


  # Builtin function `number?`.
number:
  # check argument number
  ldv   0
  pushu 2
  call  check_nargs
  # TODO
  ret


  # Builtin function `eq?`.
equal:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `car`.
car:
  # check argument number
  ldv   0
  pushu 2
  call  check_nargs
  # TODO
  ret


  # Builtin function `cdr`.
cdr:
  # check argument number
  ldv   0
  pushu 2
  call  check_nargs
  # TODO
  ret


  # Builtin function `cons`.
cons:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `list`.
list:
  # TODO
  ret


  # Builtin function `+`.
builtin_add:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `-`.
builtin_sub:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `*`.
builtin_mul:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `/`.
builtin_div:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `>`.
builtin_gt:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `<`.
builtin_lt:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `>=`.
builtin_ge:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `<=`.
builtin_le:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  # Builtin function `=`.
builtin_eq:
  # check argument number
  ldv   0
  pushu 3
  call  check_nargs
  # TODO
  ret


  .section consts
fatal:
  .str  "FATAL: "
expect_obj:
  .str  "expected Lisp object\n"
not_callable:
  .str  "object is not callable\n"
nargs_mismatch:
  .str  "number of arguments does not match\n"

object:
  .object 24, 8, [2]
ptr_object:
  .object 24, 8, [1, 2]
func_object:
  .object 40, 8, [2, 3, 4]
ptr:
  .object 8, 8, [0]


  .section exports
  .export "invoke", invoke, variadic, 0
  .export "panic", panic, 1, 0
  .export "check_nargs", check_nargs, 2, 0
  .export "new_num", new_num, 1, 1
  .export "new_str", new_str, 1, 1
  .export "new_sym", new_sym, 1, 1
  .export "new_list", new_list, variadic, 1
  .export "new_lambda", new_lambda, variadic, 1
